#  接口函数

```c
kobject_create_and_add  //开发者只需要在sysfs中创建一个目录
kobject_rename  //修改Kobject的名字
kobject_init //初始化kobj内部的参数    将ktype指针赋予kobj->ktype
kobject_add  //将初始化完成的kobject添加到kernel中
    *kobject_add_varg
    	*kobject_add_internal
    		*create_dir
kobject_init_and_add //是上面两个接口的组合，不再说明    
kobj_kset_join  //负责将kobj加入到对应kset的链表中
kobject_put //减少引用计数
   *kobject_release
    	*kobject_cleanup
    		*ktype->release
kobject_get //增加引用计数
kobject_create //自行分配空间，并内置了一个ktype
kobject_create_and_add //kobject_create和kobject_add的组合
dynamic_kobj_release //直接调用kfree释放kobj的空间
    
kset_init //初始化已分配的kset
    *kobject_init_internal
kset_register  //kset_init + kobject_add_internal将其kobject添加到kernel
kset_unregister //直接调用kobject_put释放其kobject
kset_create_and_add //动态创建一个kset+ kset_register
    *kset_create
kset_create 使用kzalloc分配一个kset空间,并定义一个kset_ktype类型的ktype
```

```c
sysfs_create_file //创建属性文件
```



## Linux设备模型(1)_基本概念

#### 1. 前言

Linux是一个宏内核，它必须面对设备的多样性，并实现对应的驱动。

为了降低设备多样性带来的Linux驱动开发的复杂度，以及设备热拔插处理、电源管理等，Linux内核提出了设备模型（也称作Driver Model）的概念。设备模型将硬件设备归纳、分类，然后抽象出一套标准的数据结构和接口。驱动的开发，就简化为对内核所规定的数据结构的填充和实现。

#### 2. Linux设备模型的基本概念

##### 2.1 Bus, Class, Device和Device Driver的概念

![device_toplogy](http://www.wowotech.net/content/uploadfile/201402/e960493a2c0e405ae9b2fefaf869334220140227080147.gif)

硬件拓扑描述Linux设备模型中四个重要概念中三个：Bus，Class和Device（第四个为Device Driver，后面会说）

Bus（总线）：Linux认为（可以参考include/linux/device.h中struct bus_type的注释），总线是CPU和一个或多个设备之间信息交互的通道。而为了方便设备模型的抽象，所有的设备都应连接到总线上（无论是CPU内部总线、虚拟的总线还是“platform Bus”）。

Class（分类）：在Linux设备模型中，Class的概念非常类似面向对象程序设计中的Class（类），它主要是集合具有相似功能或属性的设备，这样就可以抽象出一套可以在多个设备之间共用的数据结构和接口函数。因而从属于相同Class的设备的驱动程序，就不再需要重复定义这些公共资源，直接从Class中继承即可。

Device（设备）：抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。

Device Driver（驱动）：Linux设备模型用Driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现。而Linux内核中的驱动开发，基本都围绕该抽象进行（实现所规定的接口函数）。

注：什么是Platform Bus？
在计算机中有这样一类设备，它们通过各自的设备控制器，直接和CPU连接，CPU可以通过常规的寻址操作访问它们（或者说访问它们的控制器）。这种连接方式，并不属于传统意义上的总线连接。但设备模型应该具备普适性，因此Linux就虚构了一条Platform Bus，供这些设备挂靠。



##### 2.2 设备模型的核心思想

Linux设备模型的核心思想是（通过xxx手段，实现xxx目的）：

1. 用Device（struct device）和Device Driver（struct device_driver）两个数据结构，分别从“有什么用”和“怎么用”两个角度描述硬件设备。这样就统一了编写设备驱动的格式，使驱动开发从论述题变为填空体，从而简化了设备驱动的开发。
2. 同样使用Device和Device Driver两个数据结构，实现硬件设备的即插即用（热拔插）。
   在Linux内核中，只要任何Device和Device Driver具有相同的名字，内核就会执行Device Driver结构中的初始化函数（probe），该函数会初始化设备，使其为可用状态。
   而对大多数热拔插设备而言，它们的Device Driver一直存在内核中。当设备没有插入时，其Device结构不存在，因而其Driver也就不执行初始化操作。当设备插入时，内核会创建一个Device结构（名称和Driver相同），此时就会触发Driver的执行。这就是即插即用的概念。
3. 通过"Bus-->Device”类型的树状结构（见2.1章节的图例）解决设备之间的依赖，而这种依赖在开关机、电源管理等过程中尤为重要。
   试想，一个设备挂载在一条总线上，要启动这个设备，必须先启动它所挂载的总线。很显然，如果系统中设备非常多、依赖关系非常复杂的时候，无论是内核还是驱动的开发人员，都无力维护这种关系。
   而设备模型中的这种树状结构，可以自动处理这种依赖关系。启动某一个设备前，内核会检查该设备是否依赖其它设备或者总线，如果依赖，则检查所依赖的对象是否已经启动，如果没有，则会先启动它们，直到启动该设备的条件具备为止。而驱动开发人员需要做的，就是在编写设备驱动时，告知内核该设备的依赖关系即可。
4. 使用Class结构，在设备模型中引入面向对象的概念，这样可以最大限度地抽象共性，减少驱动开发过程中的重复劳动，降低工作量。

# Linux设备模型(2)_Kobject

#### 1. 前言

Kobject是Linux设备模型的基础，也是设备模型中最难理解的一部分（可参考Documentation/kobject.txt的表述[kobject.txt - Documentation/kobject.txt - Linux source code (v3.19.8) - Bootlin](https://elixir.bootlin.com/linux/v3.19.8/source/Documentation/kobject.txt)）。因此有必要先把它分析清楚。

#### 2. 基本概念

由“[Linux设备模型(1)_基本概念](http://www.wowotech.net/linux_kenrel/13.html)”可知，Linux设备模型的核心是使用Bus、Class、Device、Driver四个核心数据结构，将大量的、不同功能的硬件设备（以及驱动该硬件设备的方法），以树状结构的形式，进行归纳、抽象，从而方便Kernel的统一管理。

而硬件设备的数量、种类是非常多的，这就决定了Kernel中将会有大量的有关设备模型的数据结构。这些数据结构一定有一些共同的功能，需要抽象出来统一实现，否则就会不可避免的产生冗余代码。这就是Kobject诞生的背景。

目前为止，Kobject主要提供如下功能：

1. 通过parent指针，可以将所有Kobject以层次结构的形式组合起来。

2. 使用一个引用计数（reference count），来记录Kobject被引用的次数，并在引用次数变为0时把它释放（这是Kobject诞生时的唯一功能）。

3. 和sysfs虚拟文件系统配合，将每一个Kobject及其特性，以文件的形式，开放到用户空间（有关sysfs，会在其它文章中专门描述，本文不会涉及太多内容）。

   **注1：在Linux中，Kobject几乎不会单独存在。它的主要功能，就是内嵌在一个大型的数据结构中，为这个数据结构提供一些底层的功能实现。**
   **注2：Linux driver开发者，很少会直接使用Kobject以及它提供的接口，而是使用构建在Kobject之上的设备模型接口。**

#### 3. 代码解析

##### 3.1 在Linux Kernel source code中的位置

在Kernel源代码中，Kobject由如下两个文件实现：

- include/linux/kobject.h
- lib/kobject.c

其中kobject.h为Kobject的头文件，包含所有的数据结构定义和接口声明。kobject.c为核心功能的实现。

##### 3.2 主要的数据结构

在描述数据结构之前，有必要说明一下Kobject, Kset和Ktype这三个概念。

Kobject是基本数据类型，每个Kobject都会在"/sys/“文件系统中以目录的形式出现

Ktype代表Kobject（**严格地讲，是包含了Kobject的数据结构**）的属性操作集合（由于通用性，多个Kobject可能共用同一个属性操作集，因此把Ktype独立出来了）。

**注3：在设备模型中，ktype的命名和解释，都非常抽象，理解起来非常困难，后面会详细说明。**

Kset是一个特殊的Kobject（因此它也会在"/sys/“文件系统中以目录的形式出现），它用来集合相似的Kobject（这些Kobject可以是相同属性的，也可以不同属性的）。

- 首先看一下Kobject的原型

  ```c
   1: /* Kobject: include/linux/kobject.h line 60 */
   2: struct kobject {
   3:     const char *name;  
   4:     struct list_head    entry;
   5:     struct kobject      *parent;
   6:     struct kset     *kset;
   7:     struct kobj_type    *ktype;
   8:     struct sysfs_dirent *sd;
   9:     struct kref     kref;
   10:    unsigned int state_initialized:1;
   11:    unsigned int state_in_sysfs:1;
   12:    unsigned int state_add_uevent_sent:1;
   13:    unsigned int state_remove_uevent_sent:1;
   14:    unsigned int uevent_suppress:1;
   15: };
  /*
  name，该Kobject的名称，同时也是sysfs中的目录名称。由于Kobject添加到Kernel时，需要根据名字注册到sysfs中，之后就不能再直接修改该字段。如果需要修改Kobject的名字，需要调用kobject_rename接口，该接口会主动处理sysfs的相关事宜。
  entry，用于将Kobject加入到Kset中的list_head。
  parent，指向parent kobject，以此形成层次结构（在sysfs就表现为目录结构）。
  kset，该kobject属于的Kset。可以为NULL。如果存在，且没有指定parent，则会把Kset作为parent（别忘了Kset是一个特殊的Kobject）。
  ktype，该Kobject属于的kobj_type。每个Kobject必须有一个ktype，或者Kernel会提示错误。
  sd，该Kobject在sysfs中的表示。
  kref，"struct kref”类型（在include/linux/kref.h中定义）的变量，为一个可用于原子操作的引用计数。
  state_initialized，指示该Kobject是否已经初始化，以在Kobject的Init，Put，Add等操作时进行异常校验。
  state_in_sysfs，指示该Kobject是否已在sysfs中呈现，以便在自动注销时从sysfs中移除。
  state_add_uevent_sent/state_remove_uevent_sent，记录是否已经向用户空间发送ADD uevent，如果有，且没有发送remove uevent，则在自动注销时，补发REMOVE uevent，以便让用户空间正确处理
  uevent_suppress，如果该字段为1，则表示忽略所有上报的uevent事件。
  */
  **注4：Uevent提供了“用户空间通知”的功能实现，通过该功能，当内核中有Kobject的增加、删除、修改等动作时，会通知用户空间。有关该功能的具体内容，会在其它文章详细描述。**
  ```

  - Kset的原型为

  ```c
   1: /* include/linux/kobject.h, line 159 */
   2: struct kset {
   3:     struct list_head list;
   4:     spinlock_t list_lock;
   5:     struct kobject kobj;
   6:     const struct kset_uevent_ops *uevent_ops;
   7: };
  /*
  list/list_lock，用于保存该kset下所有的kobject的链表。
  
  kobj，该kset自己的kobject（kset是一个特殊的kobject，也会在sysfs中以目录的形式体现）。
  
  uevent_ops，该kset的uevent操作函数集。当任何Kobject需要上报uevent时，都要调用它所从属的kset的uevent_ops，添加环境变量，或者过滤event（kset可以决定哪些event可以上报）。因此，如果一个kobject不属于任何kset时，是不允许发送uevent的。
  */
  ```

- Ktype的原型为

  ```c
   1: /* include/linux/kobject.h, line 108 */
   2: struct kobj_type {
   3:     void (*release)(struct kobject *kobj);
   4:     const struct sysfs_ops *sysfs_ops;
   5:     struct attribute **default_attrs;
   6:     const struct kobj_ns_type_operations *(*child_ns_type)										(struct kobject *kobj);
   7:     const void *(*namespace)(struct kobject *kobj);
   8: };
  /*
  release，通过该回调函数，可以将包含该种类型kobject的数据结构的内存空间释放掉。
  
  sysfs_ops，该种类型的Kobject的sysfs文件系统接口。
  
  default_attrs，该种类型的Kobject的atrribute列表（所谓attribute，就是sysfs文件系统中的一个文件）。将会在Kobject添加到内核时，一并注册到sysfs中。
  
  child_ns_type/namespace，和文件系统（sysfs）的命名空间有关，这里不再详细说明。
  */
  ```

  **总结，Ktype以及整个Kobject机制的理解。**
**Kobject的核心功能是：保持一个引用计数，当该计数减为0时，自动释放（由本文所讲的kobject模块负责） Kobject所占用的meomry空间。这就决定了Kobject必须是动态分配的（只有这样才能动态释放）。**
  
  **而Kobject大多数的使用场景，是内嵌在大型的数据结构中（如Kset、device_driver等），因此这些大型的数据结构，也必须是动态分配、动态释放的。那么释放的时机是什么呢？是内嵌的Kobject释放时。但是Kobject的释放是由Kobject模块自动完成的（在引用计数为0时），那么怎么一并释放包含自己的大型数据结构呢？**
  
  **这时Ktype就派上用场了。我们知道，Ktype中的release回调函数负责释放Kobject（甚至是包含Kobject的数据结构）的内存空间，那么Ktype及其内部函数，是由谁实现呢？是由上层数据结构所在的模块！因为只有它，才清楚Kobject嵌在哪个数据结构中，并通过Kobject指针以及自身的数据结构类型，找到需要释放的上层数据结构的指针，然后释放它。**
  
  **讲到这里，就清晰多了。所以，每一个内嵌Kobject的数据结构，例如kset、device、device_driver等等，都要实现一个Ktype，并定义其中的回调函数。同理，sysfs相关的操作也一样，必须经过ktype的中转，因为sysfs看到的是Kobject，而真正的文件操作的主体，是内嵌Kobject的上层数据结构！**
  
  
  **顺便提一下，Kobject是面向对象的思想在Linux kernel中的极致体现，但C语言的优势却不在这里，所以Linux kernel需要用比较巧妙（也很啰嗦）的手段去实现，**
  
  ##### 3.3 功能分析
  
  **3.3.1 Kobject使用流程**
  
  Kobject大多数情况下（有一种例外，下面会讲）会嵌在其它数据结构中使用，其使用流程如下：
  
  1. 定义一个struct kset类型的指针，并在初始化时为它分配空间，添加到内核中
  2. 根据实际情况，定义自己所需的数据结构原型，该数据结构中包含有Kobject
  3. 定义一个适合自己的ktype，并实现其中回调函数
  4. 在需要使用到包含Kobject的数据结构时，动态分配该数据结构，并分配Kobject空间，添加到内核中
  5. 每一次引用数据结构时，调用kobject_get接口增加引用计数；引用结束时，调用kobject_put接口，减少引用计数
  6. 当引用计数减少为0时，Kobject模块调用ktype所提供的release接口，释放上层数据结构以及Kobject的内存空间
  
   
  
  上面有提过，有一种例外，Kobject不再嵌在其它数据结构中，可以单独使用，这个例外就是：开发者只需要在sysfs中创建一个目录，而不需要其它的kset、ktype的操作。这时可以直接调用kobject_create_and_add接口，分配一个kobject结构并把它添加到kernel中。
  
  **3.3.2 Kobject的分配和释放**
  
  前面讲过，Kobject必须动态分配，而不能静态定义或者位于堆栈之上，它的分配方法有两种。
  
  1. 通过kmalloc自行分配（一般是跟随上层数据结构分配），并在初始化后添加到kernel。这种方法涉及如下接口：
  
     ```c
      1: /* include/linux/kobject.h, line 85 */
      2: extern void kobject_init(struct kobject *kobj, struct					kobj_type *ktype);
      3: extern __printf(3, 4) __must_check
      4: int kobject_add(struct kobject *kobj, struct kobject *parent,
      5:                 const char *fmt, ...);
      6: extern __printf(4, 5) __must_check
      7: int kobject_init_and_add(struct kobject *kobj,
      8:             struct kobj_type *ktype, struct kobject *parent,
      9:             const char *fmt, ...);
     ```
  
     kobject_init，初始化通过kmalloc等内存分配函数获得的struct kobject指针。主要执行逻辑为：
  
     - 确认kobj和ktype不为空
     - 如果该指针已经初始化过（判断kobj->state_initialized），打印错误提示及堆栈信息（但不是致命错误，所以还可以继续）
     - 初始化kobj内部的参数，包括引用计数、list、各种标志等
     - 根据输入参数，将ktype指针赋予kobj->ktype
  
     kobject_add，将初始化完成的kobject添加到kernel中，参数包括需要添加的kobject、该kobject的parent（用于形成层次结构，可以为空）、用于提供kobject name的格式化字符串。主要执行逻辑为：
  
     - 确认kobj不为空，确认kobj已经初始化，否则错误退出
     - 调用内部接口kobject_add_varg，完成添加操作
  
     kobject_init_and_add，是上面两个接口的组合，不再说明。
  
     ==========================内部接口======================================
  
     kobject_add_varg，解析格式化字符串，将结果赋予kobj->name，之后调用kobject_add_internal接口，完成真正的添加操作。
  
     kobject_add_internal，将kobject添加到kernel。主要执行逻辑为：
  
     - 校验kobj以及kobj->name的合法性，若不合法打印错误信息并退出
     - 调用kobject_get增加该kobject的parent的引用计数（如果存在parent的话）
     - 如果存在kset（即kobj->kset不为空），则调用kobj_kset_join接口加入kset。同时，如果该kobject没有parent，却存在kset，则将它的parent设为kset（kset是一个特殊的kobject），并增加kset的引用计数
     - 通过create_dir接口，调用sysfs的相关接口，在sysfs下创建该kobject对应的目录
     - 如果创建失败，执行后续的回滚操作，否则将kobj->state_in_sysfs置为1
  
     kobj_kset_join，负责将kobj加入到对应kset的链表中。
  
     
  
     这种方式分配的kobject，会在引用计数变为0时，由kobject_put调用其ktype的release接口，释放内存空间，具体可参考后面有关kobject_put的讲解。
  
  **3.3.3 Kobject引用计数的修改**
  
  ```c
   1: /* include/linux/kobject.h, line 103 */
   2: extern struct kobject *kobject_get(struct kobject *kobj);
   3: extern void kobject_put(struct kobject *kobj);
  ```
  
  kobject_get，调用kref_get，增加引用计数。
  
  kobject_put，以内部接口kobject_release为参数，调用kref_put。kref模块会在引用计数为零时，调用kobject_release。
  
  ==========================内部接口======================================
  
  kobject_release，通过kref结构，获取kobject指针，并调用kobject_cleanup接口继续。
  
  kobject_cleanup，负责释放kobject占用的空间，主要执行逻辑如下：
  
  - 检查该kobject是否有ktype，如果没有，打印警告信息
  - 如果该kobject向用户空间发送了ADD uevent但没有发送REMOVE uevent，补发REMOVE uevent
  - 如果该kobject有在sysfs文件系统注册，调用kobject_del接口，删除它在sysfs中的注册
  - 调用该kobject的ktype的release接口，释放内存空间
  - 释放该kobject的name所占用的内存空间

**3.3.4 Kset的初始化、注册**

Kset是一个特殊的kobject，因此其初始化、注册等操作也会调用kobject的相关接口，除此之外，会有它特有的部分。另外，和Kobject一样，kset的内存分配，可以由上层软件通过kmalloc自行分配，也可以由Kobject模块负责分配，具体如下。

```c
1: /* include/linux/kobject.h, line 166 */
 2: extern void kset_init(struct kset *kset);
 3: extern int __must_check kset_register(struct kset *kset);
 4: extern void kset_unregister(struct kset *kset);
 5: extern struct kset * __must_check kset_create_and_add(const char 				*name,
 6:             const struct kset_uevent_ops *u,
 7:             struct kobject *parent_kobj);
```

kset_init，该接口用于初始化已分配的kset，主要包括调用kobject_init_internal初始化其kobject，然后初始化kset的链表。需要注意的时，如果使用此接口，上层软件必须提供该kset中的kobject的ktype。

kset_register，先调用kset_init，然后调用kobject_add_internal将其kobject添加到kernel。

kset_unregister，直接调用kobject_put释放其kobject。当其kobject的引用计数为0时，即调用ktype的release接口释放kset占用的空间。

kset_create_and_add，会调用内部接口kset_create动态创建一个kset，并调用kset_register将其注册到kernel。

==========================内部接口======================================

kset_create，该接口使用kzalloc分配一个kset空间，并定义一个kset_ktype类型的ktype，用于释放所有由它分配的kset空间。

# Linux设备模型(3)_Uevent

#### 1. Uevent的功能

Uevent是Kobject的一部分，用于在Kobject状态发生改变时，例如增加、移除等，通知用户空间程序。用户空间程序收到这样的事件后，会做相应的处理。

该机制通常是用来支持热拔插设备的，例如U盘插入后，USB相关的驱动软件会动态创建用于表示该U盘的device结构（相应的也包括其中的kobject），并告知用户空间程序，为该U盘动态的创建/dev/目录下的设备节点，更进一步，可以通知其它的应用程序，将该U盘设备mount到系统中，从而动态的支持该设备。

#### 2. Uevent在kernel中的位置

下面图片描述了Uevent模块在内核中的位置

![uevent](http://www.wowotech.net/content/uploadfile/201403/430b8239af589fedfe6ecffbd26dcbae20140311063954.gif)：

由此可知，Uevent的机制是比较简单的，设备模型中任何设备有事件需要上报时，会触发Uevent提供的接口。Uevent模块准备好上报事件的格式后，可以通过两个途径把事件上报到用户空间：一种是通过kmod模块，直接调用用户空间的可执行文件；另一种是通过netlink通信机制，将事件从内核空间传递给用户空间。

#### 3. Uevent的内部逻辑解析

##### 3.1 Source Code位置

Uevent的代码比较简单，主要涉及kobject.h和kobject_uevent.c两个文件，如下：

- include/linux/kobject.h
- lib/kobject_uevent.c

##### 3.2 数据结构描述

kobject.h定义了uevent相关的常量和数据结构，如下：

- kobject_action

  ```c
   1: /* include/linux/kobject.h, line 50 */
   2: enum kobject_action {   
   3:     KOBJ_ADD,
   4:     KOBJ_REMOVE,    
   5:     KOBJ_CHANGE, 
   6:     KOBJ_MOVE,
   7:     KOBJ_ONLINE, 
   8:     KOBJ_OFFLINE,
   9:     KOBJ_MAX 
   10: };
  ```

kobject_action定义了event的类型，包括：

ADD/REMOVE，Kobject（或上层数据结构）的添加/移除事件。

ONLINE/OFFLINE，Kobject（或上层数据结构）的上线/下线事件，其实是是否使能。

CHANGE，Kobject（或上层数据结构）的状态或者内容发生改变。

MOVE，Kobject（或上层数据结构）更改名称或者更改Parent（意味着在sysfs中更改了目录结构）。

CHANGE，如果设备驱动需要上报的事件不在上面事件的范围内，或者是自定义的事件，可以使用该event，并携带相应的参数。

- kobj_uevent_env

  ```c
   1: /* include/linux/kobject.h, line 31 */
   2: #define UEVENT_NUM_ENVP         32 /* number of env pointers */
   3: #define UEVENT_BUFFER_SIZE      2048 /* buffer for the variables                                           */
   4:  
   5: /* include/linux/kobject.h, line 116 */
   6: struct kobj_uevent_env {
   7:     char *envp[UEVENT_NUM_ENVP];
   8:     int envp_idx;
   9:     char buf[UEVENT_BUFFER_SIZE];
   10:    int buflen;
   11: };          
  ```

  前面有提到过，在利用Kmod向用户空间上报event事件时，会直接执行用户空间的可执行文件。而在Linux系统，可执行文件的执行，依赖于环境变量，因此kobj_uevent_env用于组织此次事件上报时的环境变量。

envp，指针数组，用于保存每个环境变量的地址，最多可支持的环境变量数量为UEVENT_NUM_ENVP。

envp_idx，用于访问环境变量指针数组的index。

buf，保存环境变量的buffer，最大为UEVENT_BUFFER_SIZE。

buflen，访问buf的变量。



- kset_uevent_ops

```c
 1: /* include/linux/kobject.h, line 123 */
 2: struct kset_uevent_ops {
 3:     int (* const filter)(struct kset *kset, struct kobject *kobj);
 4:     const char *(* const name)(struct kset *kset, struct kobject 									*kobj);
 5:     int (* const uevent)(struct kset *kset, struct kobject *kobj,
 6:                         struct kobj_uevent_env *env);
 7: };
```

kset_uevent_ops是为kset量身订做的一个数据结构，里面包含filter和uevent两个回调函数，用处如下：

filter，当任何Kobject需要上报uevent时，它所属的kset可以通过该接口过滤，阻止不希望上报的event，从而达到从整体上管理的目的。

name，该接口可以返回kset的名称。如果一个kset没有合法的名称，则其下的所有Kobject将不允许上报uevent

uevent，当任何Kobject需要上报uevent时，它所属的kset可以通过该接口统一为这些event添加环境变量。因为很多时候上报uevent时的环境变量都是相同的，因此可以由kset统一处理，就不需要让每个Kobject独自添加了。

##### 3.3 内部动作

通过kobject.h，uevent模块提供了如下的API（这些API的实现是在"lib/kobject_uevent.c”文件中）：

```c
 1: /* include/linux/kobject.h, line 206 */
 2: int kobject_uevent(struct kobject *kobj, enum kobject_action 								action);
 3: int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,
 4:                         char *envp[]);
 5:  
 6: __printf(2, 3)
 7: int add_uevent_var(struct kobj_uevent_env *env, const char *format, 						...);
 8:  
 9: int kobject_action_type(const char *buf, size_t count,
 10:                         enum kobject_action *type);
```

kobject_uevent_env，以envp为环境变量，上报一个指定action的uevent。环境变量的作用是为执行用户空间程序指定运行环境。具体动作如下：

kobject_uevent_env，以envp为环境变量，上报一个指定action的uevent。环境变量的作用是为执行用户空间程序指定运行环境。具体动作如下：

- 查找kobj本身或者其parent是否从属于某个kset，如果不是，则报错返回（注2：由此可以说明，如果一个kobject没有加入kset，是不允许上报uevent的）
- 查看kobj->uevent_suppress是否设置，如果设置，则忽略所有的uevent上报并返回（注3：由此可知，可以通过Kobject的uevent_suppress标志，管控Kobject的uevent的上报）
- 如果所属的kset有uevent_ops->filter函数，则调用该函数，过滤此次上报（注4：这佐证了3.2小节有关filter接口的说明，kset可以通过filter接口过滤不希望上报的event，从而达到整体的管理效果）
- 判断所属的kset是否有合法的名称（称作subsystem，和前期的内核版本有区别），否则不允许上报uevent
- 分配一个用于此次上报的、存储环境变量的buffer（结果保存在env指针中），并获得该Kobject在sysfs中路径信息（用户空间软件需要依据该路径信息在sysfs中访问它）
- 调用add_uevent_var接口（下面会介绍），将Action、路径信息、subsystem等信息，添加到env指针中
- 如果传入的envp不空，则解析传入的环境变量中，同样调用add_uevent_var接口，添加到env指针中
- 如果所属的kset存在uevent_ops->uevent接口，调用该接口，添加kset统一的环境变量到env指针
- 根据ACTION的类型，设置kobj->state_add_uevent_sent和kobj->state_remove_uevent_sent变量，以记录正确的状态
- 调用add_uevent_var接口，添加格式为"SEQNUM=%llu”的序列号
- 如果定义了"CONFIG_NET”，则使用netlink发送该uevent
- 以uevent_helper、subsystem以及添加了标准环境变量（HOME=/，PATH=/sbin:/bin:/usr/sbin:/usr/bin）的env指针为参数，调用kmod模块提供的call_usermodehelper函数，上报uevent。
  其中uevent_helper的内容是由内核配置项CONFIG_UEVENT_HELPER_PATH(位于./drivers/base/Kconfig)决定的(可参考lib/kobject_uevent.c, line 32)，该配置项指定了一个用户空间程序（或者脚本），用于解析上报的uevent，例如"/sbin/hotplug”。
  call_usermodehelper的作用，就是fork一个进程，以uevent为参数，执行uevent_helper。

kobject_uevent，和kobject_uevent_env功能一样，只是没有指定任何的环境变量。

add_uevent_var，以格式化字符的形式（类似printf、printk等），将环境变量copy到env指针中。

kobject_action_type，将enum kobject_action类型的Action，转换为字符串。

**说明：怎么指定处理uevent的用户空间程序(简称uevent helper)？

上面介绍kobject_uevent_env的内部动作时，有提到，Uevent模块通过Kmod上报Uevent时，会通过call_usermodehelper函数，调用用户空间的可执行文件（或者脚本，简称\**uevent helper\** ）处理该event。而该uevent helper的路径保存在\**uevent_helper数组中。

可以在编译内核时，通过CONFIG_UEVENT_HELPER_PATH配置项，静态指定uevent helper。但这种方式会为每个event fork一个进程，随着内核支持的设备数量的增多，这种方式在系统启动时将会是致命的（可以导致内存溢出等）。因此只有在早期的内核版本中会使用这种方式，现在内核不再推荐使用该方式。因此内核编译时，需要把该配置项留空。

在系统启动后，大部分的设备已经ready，可以根据需要，重新指定一个uevent helper，以便检测系统运行过程中的热拔插事件。这可以通过把helper的路径写入到"/sys/kernel/uevent_helper”文件中实现。实际上，内核通过sysfs文件系统的形式，将uevent_helper数组开放到用户空间，供用户空间程序修改访问，具体可参考"./kernel/ksysfs.c”中相应的代码，这里不再详细描述。



## Linux设备模型(4)_sysfs

#### 1. 前言

sysfs是一个基于RAM的文件系统，它和Kobject一起，可以将Kernel的数据结构导出到用户空间，以文件目录结构的形式，提供对这些数据结构（以及数据结构的属性）的访问支持。

sysfs具备文件系统的所有属性，而本文主要侧重其设备模型的特性,因此不会涉及过多的文件系统实现细节，而只介绍sysfs在Linux设备模型中的作用和使用方法。具体包括：

- sysfs和Kobject的关系

- attribute的概念

- sysfs的文件系统操作接口

  

#### 2. sysfs和Kobject的关系

在"[Linux设备模型_Kobject](http://www.wowotech.net/linux_kenrel/kobject.html)”文章中，有提到过，每一个Kobject，都会对应sysfs中的一个目录。因此在将Kobject添加到Kernel时，create_dir接口会调用sysfs文件系统的创建目录接口，创建和Kobject对应的目录，相关的代码如下：

```c
1: /* lib/kobject.c, line 47 */
 2: static int create_dir(struct kobject *kobj)
 3: {
 4:     int error = 0;
 5:     error = sysfs_create_dir(kobj);
 6:     if (!error) {
 7:         error = populate_dir(kobj);
 8:     if (error)
 9:         sysfs_remove_dir(kobj);
 10:     }   
 11:     return error;
 12: }
 13:  
 14: /* fs/sysfs/dir.c, line 736 */
 15: **
 16: *  sysfs_create_dir - create a directory for an object.
 17: *  @kobj:      object we're creating directory for. 
 18: */
 19: int sysfs_create_dir(struct kobject * kobj)
 20: {
 21:     enum kobj_ns_type type;
 22:     struct sysfs_dirent *parent_sd, *sd;
 23:     const void *ns = NULL;
 24:     int error = 0;
 25:     ...
 26: }
```

#### 3. attribute

##### 3.1 attribute的功能概述

在sysfs中，为什么会有attribute的概念呢？其实它是对应kobject而言的，指的是kobject的“属性”。我们知道，

sysfs中的目录描述了kobject，而kobject是特定数据类型变量（如struct device）的体现。因此kobject的属性，就是这些变量的属性。它可以是任何东西，名称、一个内部变量、一个字符串等等。而attribute，在sysfs文件系统中是以文件的形式提供的，即：kobject的所有属性，都在它对应的sysfs目录下以文件的形式呈现。这些文件一般是可读、写的，而kernel中定义了这些属性的模块，会根据用户空间的读写操作，记录和返回这些attribute的值。

总结一下：所谓的attibute，就是内核空间和用户空间进行信息交互的一种方法。例如某个driver定义了一个变量，却希望用户空间程序可以修改该变量，以控制driver的运行行为，那么就可以将该变量以sysfs attribute的形式开放出来。

Linux内核中，attribute分为普通的attribute和二进制attribute，如下：

```c
 1: /* include/linux/sysfs.h, line 26 */
 2: struct attribute {
 3:     const char *name;
 4:     umode_t         mode;
 5: #ifdef CONFIG_DEBUG_LOCK_ALLOC
 6:     bool ignore_lockdep:1;
 7:     struct lock_class_key   *key;
 8:     struct lock_class_key   skey;
 9: #endif
 10: };
 11:  
 12: /* include/linux/sysfs.h, line 100 */
 13: struct bin_attribute {
 14:     struct attribute    attr;
 15:     size_t          size;
 16:     void *private;
 17:     ssize_t (*read)(struct file *, struct kobject *, struct 									bin_attribute *,
 18:                     char *, loff_t, size_t);
 19:     ssize_t (*write)(struct file *,struct kobject *, struct 									bin_attribute *,
 20:                     char *, loff_t, size_t);
 21:     int (*mmap)(struct file *, struct kobject *, struct 								bin_attribute *attr,
 22:                     struct vm_area_struct *vma);
 23: };
```

struct attribute为普通的attribute，使用该attribute生成的sysfs文件，只能用字符串的形式读写（后面会说为什么）。而struct bin_attribute在struct attribute的基础上，增加了read、write等函数，因此它所生成的sysfs文件可以用任何方式读写。

说完基本概念，我们要问两个问题：

Kernel怎么把attribute变成sysfs中的文件呢？

用户空间对sysfs的文件进行的读写操作，怎么传递给Kernel呢？

下面来看看这个过程。

##### 3.2 attibute文件的创建

在linux内核中，attibute文件的创建是由fs/sysfs/file.c中sysfs_create_file接口完成的，该接口的实现没有什么特殊之处，大多是文件系统相关的操作，和设备模型没有太多的关系，这里先略过不提。

##### 3.3 attibute文件的read和write

看到3.1章节struct attribute的原型时，也许我们会犯嘀咕，该结构很简单啊，name表示文件名称，mode表示文件模式，其它的字段都是内核用于debug Kernel Lock的，那文件操作的接口在哪里呢？

不着急，我们去fs/sysfs目录下看看sysfs相关的代码逻辑。

所有的文件系统，都会定义一个struct file_operations变量，用于描述本文件系统的操作接口，sysfs也不例外：

```c
 1: /* fs/sysfs/file.c, line 472 */
 2: const struct file_operations sysfs_file_operations = {
 3:     .read       = sysfs_read_file,
 4:     .write      = sysfs_write_file,
 5:     .llseek     = generic_file_llseek,
 6:     .open       = sysfs_open_file,
 7:     .release    = sysfs_release,
 8:     .poll       = sysfs_poll,
 9: };
```

attribute文件的read操作，会由VFS转到sysfs_file_operations的read（也就是sysfs_read_file）接口上，让我们大概看一下该接口的处理逻辑。

```c
1: /* fs/sysfs/file.c, line 127 */
 2: static ssize_t
 3: sysfs_read_file(struct file *file, char __user *buf, size_t count, 						loff_t *ppos)
 4: {
 5:     struct sysfs_buffer * buffer = file->private_data;
 6:     ssize_t retval = 0;
 7:  
 8:     mutex_lock(&buffer->mutex);
 9:     if (buffer->needs_read_fill || *ppos == 0) {
 10:        retval = fill_read_buffer(file->f_path.dentry,buffer);
 11:        if (retval)
 12:            goto out;
 13:    }
 14: ...
 15: }
 16: /* fs/sysfs/file.c, line 67 */
 17: static int fill_read_buffer(struct dentry * dentry, struct 										sysfs_buffer * buffer)
 18: {           
 19:    struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 20:    struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 21:    const struct sysfs_ops * ops = buffer->ops;
 22:    ...        
 23:    count = ops->show(kobj, attr_sd->s_attr.attr, buffer->page);
 24:    ...
 25: }
```

## Linux设备模型(5)_device和device driver

**1. 前言**

device和device driver是Linux驱动开发的基本概念。Linux kernel的思路很简单：驱动开发，就是要开发指定的软件（driver）以驱动指定的设备，所以kernel就为设备和驱动它的driver定义了两个数据结构，分别是device和device_driver。因此本文将会围绕这两个数据结构，介绍Linux设备模型的核心逻辑，包括：

设备及设备驱动在kernel中的抽象、使用和维护；

设备及设备驱动的注册、加载、初始化原理；

设备模型在实际驱动开发过程中的使用方法。

注：在介绍device和device_driver的过程中，会遇到很多额外的知识点，如Class、Bus、DMA、电源管理等等，这些知识点都很复杂，任何一个都可以作为一个单独的专题区阐述，因此本文不会深入解析它们，而会在后续的文章中专门描述。

**2. struct device和struct device_driver**

在阅读Linux内核源代码时，通过核心数据结构，即可理解某个模块60%以上的逻辑，设备模型部分尤为明显。

在include/linux/device.h中，Linux内核定义了设备模型中最重要的两个数据结构，struct device和struct device_driver。

- struct device

  ```c
   1: /* include/linux/device.h, line 660 */
   2: struct device {
   3:     struct device       *parent;
   4:  
   5:     struct device_private   *p;
   6:  
   7:     struct kobject kobj;
   8:     const char *init_name; /* initial name of the device */
   9:     const struct device_type *type;
   10:  
   11:    struct mutex        mutex; /* mutex to synchronize calls to
   12:                             * its driver.
   13:                             */
   14:  
   15:    struct bus_type *bus; /* type of bus device is on */
   16:    struct device_driver *driver; /* which driver has allocated 										this
   17:                                 device */
   18:    void *platform_data; /* Platform specific data, device
   19:                         core doesn't touch it */
   20:    struct dev_pm_info  power;
   21:    struct dev_pm_domain    *pm_domain;
   22:  
   23: #ifdef CONFIG_PINCTRL
   24:    struct dev_pin_info *pins;
   25: #endif
   26:  
   27: #ifdef CONFIG_NUMA
   28:    int numa_node; /* NUMA node this device is close to */
   29: #endif
   30:    u64     *dma_mask; /* dma mask (if dma'able device) */
   31:    u64     coherent_dma_mask;/* Like dma_mask, but for
   32:                             alloc_coherent mappings as
   33:                             not all hardware supports
   34:                             64 bit addresses for consistent
   35:                             allocations such descriptors. */
   36:  
   37:    struct device_dma_parameters *dma_parms;
   38:  
   39:    struct list_head    dma_pools; /* dma pools (if dma'ble) */
   40:  
   41:    struct dma_coherent_mem *dma_mem; /* internal for coherent 								mem
   42:                            override */
   43: #ifdef CONFIG_CMA
   44:    struct cma *cma_area; /* contiguous memory area for dma
   45:                            allocations */
   46: #endif
   47:    /* arch specific additions */
   48:    struct dev_archdata archdata;
   49:  
   50:    struct device_node  *of_node; /* associated device tree node 										*/
   51:    struct acpi_dev_node    acpi_node; /* associated ACPI device 											node */
   52:  
   53:    dev_t           devt; /* dev_t, creates the sysfs "dev" */
   54:    u32         id; /* device instance */
   55:  
   56:    spinlock_t      devres_lock;
   57:    struct list_head    devres_head;
   58:  
   59:    struct klist_node   knode_class;
   60:    struct class *class;
   61:    const struct attribute_group **groups; /* optional groups */
   62:  
   63:    void (*release)(struct device *dev);
   64:    struct iommu_group  *iommu_group;
   65: };
  ```

  device结构很复杂（不过linux内核的开发人员素质是很高的，该接口的注释写的非常详细，感兴趣的同学可以参考内核源代码），这里将会选一些对理解设备模型非常关键的字段进行说明。

  parent，该设备的父设备，一般是该设备所从属的bus、controller等设备。

  p，一个用于struct device的私有数据结构指针，该指针中会保存子设备链表、用于添加到bus/driver/prent等设备中的链表头等等，具体可查看源代码。

  kobj，该数据结构对应的struct kobject。

  init_name，该设备的名称。

  ​    注1：在设备模型中，名称是一个非常重要的变量，任何注册到内核中的设备，都必须有一个合法的名称，可以在初始化时给出，也可以由内核根据“bus name + device ID”的方式创造。

  type，struct device_type结构是新版本内核新引入的一个结构，它和struct device关系，非常类似[stuct kobj_type和struct kobject](http://www.wowotech.net/linux_kenrel/kobject.html)之间的关系，后续会再详细说明。

  bus，该device属于哪个总线（后续会详细描述）。

  driver，该device对应的device driver。

  platform_data，一个指针，用于保存具体的平台相关的数据。具体的driver模块，可以将一些私有的数据，暂存在这里，需要使用的时候，再拿出来，因此设备模型并不关心该指针得实际含义。

  power、pm_domain，电源管理相关的逻辑，后续会由电源管理专题讲解。

  pins，"PINCTRL”功能，暂不描述。

  numa_node，"NUMA”功能，暂不描述。

  dma_mask~archdata，DMA相关的功能，暂不描述。

  devt，dev_t是一个32位的整数，它由两个部分（Major和Minor）组成，在需要以设备节点的形式（字符设备和块设备）向用户空间提供接口的设备中，当作设备号使用。在这里，该变量主要用于在sys文件系统中，为每个具有设备号的device，创建/sys/dev/* 下的对应目录，如下：

  1|root@android:/storage/sdcard0 #ls /sys/dev/char/1\:                                   
  1:1/ 1:11/ 1:13/ 1:14/ 1:2/ 1:3/ 1:5/ 1:7/ 1:8/ 1:9/ 
  1|root@android:/storage/sdcard0 #ls /sys/dev/char/1:1                                  
  1:1/ 1:11/ 1:13/ 1:14/
  1|root@android:/storage/sdcard0 # ls /sys/dev/char/1\:1 
  /sys/dev/char/1:1 

  class，该设备属于哪个class。

  groups，该设备的默认attribute集合。将会在设备注册时自动在sysfs中创建对应的文件。

  

  - struct device_driver

  ```c
   1: /* include/linux/device.h, line 213 */
   2: struct device_driver {  
   3:     const char *name;  
   4:     struct bus_type     *bus;
   5:  
   6:     struct module       *owner;
   7:     const char *mod_name; /* used for built-in modules */
   8:  
   9:     bool suppress_bind_attrs; /* disables bind/unbind via sysfs */
   10:  
   11:    const struct of_device_id   *of_match_table;
   12:    const struct acpi_device_id *acpi_match_table;
   13:  
   14:    int (*probe) (struct device *dev);
   15:    int (*remove) (struct device *dev);
   16:    void (*shutdown) (struct device *dev);
   17:    int (*suspend) (struct device *dev, pm_message_t state);
   18:    int (*resume) (struct device *dev);
   19:    const struct attribute_group **groups;
   20:  
   21:    const struct dev_pm_ops *pm;
   22:  
   23:    struct driver_private *p;
   24: };
  ```

  device_driver就简单多了（在早期的内核版本中driver的数据结构为"struct driver”，不知道从哪个版本开始，就改成device_driver了）：

  name，该driver的名称。和device结构一样，该名称非常重要，后面会再详细说明。

  bus，该driver所驱动设备的总线设备。为什么driver需要记录总线设备的指针呢？因为内核要保证在driver运行前，设备所依赖的总线能够正确初始化。

  owner、mod_name，內核module相关的变量，暂不描述。

  suppress_bind_attrs，是不在sysfs中启用bind和unbind attribute，如下：root@android:/storage/sdcard0 # ls /sys/bus/platform/drivers/switch-gpio/                         
  bind  uevent unbind
  在kernel中，bind/unbind是从用户空间手动的为driver绑定/解绑定指定的设备的机制。这种机制是在bus.c中完成的，后面会详细解释。

  probe、remove，这两个接口函数用于实现driver逻辑的开始和结束。Driver是一段软件code，因此会有开始和结束两个代码逻辑，就像PC程序，会有一个main函数，main函数的开始就是开始，return的地方就是结束。而内核driver却有其特殊性：在设备模型的结构下，只有driver和device同时存在时，才需要开始执行driver的代码逻辑。这也是probe和remove两个接口名称的由来：检测到了设备和移除了设备（就是为热拔插起的！）。

  shutdown、suspend、resume、pm，电源管理相关的内容，会在电源管理专题中详细说明。

  groups，和struct device结构中的同名变量类似，driver也可以定义一些默认attribute，这样在将driver注册到内核中时，内核设备模型部分的代码（driver/base/driver.c）会自动将这些attribute添加到sysfs中。

  p，driver core的私有数据指针，其它模块不能访问。

  

**3. 设备模型框架下驱动开发的基本步骤**

在设备模型框架下，设备驱动的开发是一件很简单的事情，主要包括2个步骤：

步骤1：分配一个struct device类型的变量，填充必要的信息后，把它注册到内核中。

步骤2：分配一个struct device_driver类型的变量，填充必要的信息后，把它注册到内核中。

这两步完成后，内核会在合适的时机（后面会讲），调用struct device_driver变量中的probe、remove、suspend、resume等回调函数，从而触发或者终结设备驱动的执行。而所有的驱动程序逻辑，都会由这些回调函数实现，此时，驱动开发者眼中便不再有“设备模型”，转而只关心驱动本身的实现。

以上两个步骤的补充说明：

1. 一般情况下，Linux驱动开发很少直接使用device和device_driver，因为内核在它们之上又封装了一层，如soc device、platform device等等，而这些层次提供的接口更为简单、易用（也正是因为这个原因，本文并不会过多涉及device、device_driver等模块的实现细节）。

2. 内核提供很多struct device结构的操作接口（具体可以参考include/linux/device.h和drivers/base/core.c的代码），主要包括初始化（device_initialize）、注册到内核（device_register）、分配存储空间+初始化+注册到内核（device_create）等等，可以根据需要使用。

3. device和device_driver必须具备相同的名称，内核才能完成匹配操作，进而调用device_driver中的相应接口。这里的同名，作用范围是同一个bus下的所有device和device_driver。

4. device和device_driver必须挂载在一个bus之下，该bus可以是实际存在的，也可以是虚拟的。

5. driver开发者可以在struct device变量中，保存描述设备特征的信息，如寻址空间、依赖的GPIOs等，因为device指针会在执行probe等接口时传入，这时driver就可以根据这些信息，执行相应的逻辑操作了。

**4. 设备驱动probe的时机**

所谓的"probe”，是指在Linux内核中，如果存在相同名称的device和device_driver（注：还存在其它方式，我们先不关注了），内核就会执行device_driver中的probe回调函数，而该函数就是所有driver的入口，可以执行诸如硬件设备初始化、字符设备注册、设备文件操作ops注册等动作（"remove”是它的反操作，发生在device或者device_driver任何一方从内核注销时，其原理类似，就不再单独说明了）。

设备驱动prove的时机有如下几种（分为自动触发和手动触发）

- 将struct device类型的变量注册到内核中时自动触发（device_register，device_add，device_create_vargs，device_create）
- 将struct device_driver类型的变量注册到内核中时自动触发（driver_register）
- 手动查找同一bus下的所有device_driver，如果有和指定device同名的driver，执行probe操作（device_attach）
- 手动查找同一bus下的所有device，如果有和指定driver同名的device，执行probe操作（driver_attach）
- 自行调用driver的probe接口，并在该接口中将该driver绑定到某个device结构中----即设置dev->driver（device_bind_driver）

注2：probe动作实际是由bus模块（会在下一篇文章讲解）实现的，这不难理解：device和device_driver都是挂载在bus这根线上，因此只有bus最清楚应该为哪些device、哪些driver配对。

注3：每个bus都有一个drivers_autoprobe变量，用于控制是否在device或者driver注册时，自动probe。该变量默认为1（即自动probe），bus模块将它开放到sysfs中了，因而可在用户空间修改，进而控制probe行为。

**5. 其它杂项**

在"[Linux设备模型(4)_sysfs](http://www.wowotech.net/linux_kenrel/dm_sysfs.html)”中，我们有讲到，大多数时候，attribute文件的读写数据流为：vfs---->sysfs---->kobject---->attibute---->kobj_type---->sysfs_ops---->xxx_attribute，其中kobj_type、sysfs_ops和xxx_attribute都是由包含kobject的上层数据结构实现。

Linux内核中关于该内容的例证到处都是，device也不无例外的提供了这种例子，如下：

```c
 1: /* driver/base/core.c, line 118 */
 2: static ssize_t dev_attr_show(struct kobject *kobj, struct attribute *attr,
 3: char *buf) 
 4: {   
 5:     struct device_attribute *dev_attr = to_dev_attr(attr);
 6:     struct device *dev = kobj_to_dev(kobj);
 7:     ssize_t ret = -EIO;
 8: 
 9:     if (dev_attr->show)
 10:        ret = dev_attr->show(dev, dev_attr, buf);
 11:        if (ret >= (ssize_t)PAGE_SIZE) {
 12:            print_symbol("dev_attr_show: %s returned bad count\n",
 13:                        (unsigned long)dev_attr->show);
 14:    }
 15:    return ret;
 16: }
 17:  
 18: static ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr,
 19: const char *buf, size_t count)
 20: {
 21:    struct device_attribute *dev_attr = to_dev_attr(attr);
 22:    struct device *dev = kobj_to_dev(kobj);
 23:    ssize_t ret = -EIO;
 24: 
 25:    if (dev_attr->store)
 26:        ret = dev_attr->store(dev, dev_attr, buf, count);
 27:    return ret;
 28: }
 29:  
 30: static const struct sysfs_ops dev_sysfs_ops = {
 31:    .show   = dev_attr_show,
 32:    .store  = dev_attr_store,
 33: };
 34:  
 35: /* driver/base/core.c, line 243 */
 36: static struct kobj_type device_ktype = {
 37:    .release    = device_release,
 38:    .sysfs_ops  = &dev_sysfs_ops,
 39:    .namespace = device_namespace,
 40: };
 41:  
 42: /* include/linux/device.h, line 478 */
 43: /* interface for exporting device attributes */
 44: struct device_attribute {
 45:    struct attribute    attr;
 46:    ssize_t (*show)(struct device *dev, struct device_attribute *attr,
 47:                    char *buf);
 48:    ssize_t (*store)(struct device *dev, struct device_attribute *attr,
 49:                    const char *buf, size_t count);
 50: };
```

至于driver的attribute，则要简单的多，其数据流为：vfs---->sysfs---->kobject---->attribute---->driver_attribute，如下：

```c
 1: /* include/linux/device.h, line 247 */
 2: /* sysfs interface for exporting driver attributes */
 3:  
 4: struct driver_attribute {
 5:     struct attribute attr;
 6:     ssize_t (*show)(struct device_driver *driver, char *buf);
 7:     ssize_t (*store)(struct device_driver *driver, const char *buf,
 8:                     size_t count);
 9: };
 10:  
 11: #define DRIVER_ATTR(_name, _mode, _show, _store)    \
 12: struct driver_attribute driver_attr_##_name =       \
 13:    __ATTR(_name, _mode, _show, _store)
```

**5.2 device_type**

device_type是内嵌在struct device结构中的一个数据结构，用于指明设备的类型，并提供一些额外的辅助功能。它的的形式如下：

```c
 1: /* include/linux/device.h, line 467 */
 2: struct device_type {
 3:     const char *name;
 4:     const struct attribute_group **groups;
 5:     int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 6:     char *(*devnode)(struct device *dev, umode_t *mode,
 7:                     kuid_t *uid, kgid_t *gid);
 8:     void (*release)(struct device *dev);
 9:  
 10:    const struct dev_pm_ops *pm;
 11: };
```

device_type的功能包括：

- name表示该类型的名称，当该类型的设备添加到内核时，内核会发出"DEVTYPE=‘name’”类型的uevent，告知用户空间某个类型的设备available了

- groups，该类型设备的公共attribute集合。设备注册时，会同时注册这些attribute。这就是面向对象中“继承”的概念

- uevent，同理，所有相同类型的设备，会有一些共有的uevent需要发送，由该接口实现

- devnode，devtmpfs有关的内容，暂不说明

- release，如果device结构没有提供release接口，就要查询它所属的type是否提供。用于释放device变量所占的空间

  

**5.3 root device**

在sysfs中有这样一个目录：/sys/devices，系统中所有的设备，都归集在该目录下。有些设备，是通过device_register注册到Kernel并体现在/sys/devices/xxx/下。但有时候我们仅仅需要在/sys/devices/下注册一个目录，该目录不代表任何的实体设备，这时可以使用下面的接口：

```c
 1: /* include/linux/device.h, line 859 */
 2: /*
 3:  * Root device objects for grouping under /sys/devices
 4:  */
 5: extern struct device *__root_device_register(const char *name,
 6: struct module *owner);
 7:  
 8: /*
 9:  * This is a macro to avoid include problems with THIS_MODULE,
 10:  * just as per what is done for device_schedule_callback() above.
 11:  */
 12: #define root_device_register(name) \
 13: __root_device_register(name, THIS_MODULE)
 14:  
 15: extern void root_device_unregister(struct device *root);
```

该接口会调用device_register函数，向内核中注册一个设备，但是（你也想到了），没必要注册与之对应的driver（顺便提一下，内核中有很多不需要driver的设备，这是之一）。

# Linux设备模型(6)_Bus

### 1.概述

内核规定，系统中的每个设备都要连接在一个Bus上

分类：内部bus 虚拟bus Platform bus 

### 2.功能说明

##### 2.1 struct bus_type

```c
 1: /* inlcude/linux/device.h, line 93 */
 2: struct bus_type {
 3:     const char *name;
 4:     const char *dev_name;
 5:     struct device       *dev_root;
 6:     struct bus_attribute    *bus_attrs;
 7:     struct device_attribute *dev_attrs;
 8:     struct driver_attribute *drv_attrs;
 9:  
 10:    int (*match)(struct device *dev, struct device_driver *drv);
 11:    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 12:    int (*probe)(struct device *dev);
 13:    int (*remove)(struct device *dev);
 14:    void (*shutdown)(struct device *dev);
 15:  
 16:    int (*suspend)(struct device *dev, pm_message_t state);
 17:    int (*resume)(struct device *dev);
 18:  
 19:    const struct dev_pm_ops *pm;
 20:  
 21:    struct iommu_ops *iommu_ops;
 22:  
 23:    struct subsys_private *p;
 24:    struct lock_class_key lock_key;
 25: };


	name:该bus的名称，会在sysfs中以目录的形式存在，如platform bus在sysfs中表现为"/sys/bus/platform”

    dev_name，该名称和"Linux设备模型(5)_device和device driver”所讲述的struct device结构中的init_name有关。对有些设备而言（例如批量化的USB设备），设计者根本就懒得为它起名字的，而内核也支持这种懒惰，允许将设备的名字留空。这样当设备注册到内核后，设备模型的核心逻辑就会用"bus->dev_name+device ID”的形式，为这样的设备生成一个名称。
bus_attrs、dev_attrs、drv_attrs，一些默认的attribute，可以在bus、device或者

	device_driver添加到内核时，自动为它们添加相应的attribute。

    dev_root，根据内核的注释，dev_root设备为bus的默认父设备（Default device to use as the parent），但在内核实际实现中，只和一个叫sub system的功能有关

	match，一个由具体的bus driver实现的回调函数。当任何属于该Bus的device或者device_driver添加到内核时，内核都会调用该接口，如果新加的device或device_driver匹配上了自己的另一半的话，该接口要返回非零值，此时Bus模块的核心逻辑就会执行后续的处理。
 
	uevent，一个由具体的bus driver实现的回调函数。当任何属于该Bus的device，发生添加、移除或者其它动作时，Bus模块的核心逻辑就会调用该接口，以便bus driver能够修改环境变量。
	probe、remove，这两个回调函数，和device_driver中的非常类似，但它们的存在是非常有意义的。可以想象一下，如果需要probe（其实就是初始化）指定的device话，需要保证该device所在的bus是被初始化过、确保能正确工作的。这就要就在执行device_driver的probe前，先执行它的bus的probe。remove的过程相反。
    注1：并不是所有的bus都需要probe和remove接口的，因为对有些bus来说（例如platform bus），它本身就是一个虚拟的总线，无所谓初始化，直接就能使用，因此这些bus的driver就可以将这两个回调函数留空。 
        
   	p，一个struct subsys_private类型的指针，后面我们会用一个小节说明。
```

##### 2.2 struct subsys_private

```c
 1: /* drivers/base/base.h, line 28 */
 2: struct subsys_private {
 3:     struct kset subsys;
 4:     struct kset *devices_kset;
 5:     struct list_head interfaces;
 6:     struct mutex mutex;
 7:  
 8:     struct kset *drivers_kset;
 9:     struct klist klist_devices;
 10:    struct klist klist_drivers;
 11:    struct blocking_notifier_head bus_notifier;
 12:    unsigned int drivers_autoprobe:1;
 13:    struct bus_type *bus;
 14:  
 15:    struct kset glue_dirs;
 16:    struct class *class;
 17: };

   subsys、devices_kset、drivers_kset是三个kset，由"Linux设备模型(2)_Kobject”中对kset的描述可知，kset是一个特殊的kobject，用来集合相似的kobject，它在sysfs中也会以目录的形式体现。其中subsys，代表了本bus（如/sys/bus/spi），它下面可以包含其它的kset或者其它的kobject；devices_kset和drivers_kset则是bus下面的两个kset（如/sys/bus/spi/devices和/sys/bus/spi/drivers），分别包括本bus下所有的device和device_driver。 
       
      interface是一个list head，用于保存该bus下所有的interface。有关interface的概念后面会详细介绍
       
       klist_devices和klist_drivers是两个链表，分别保存了本bus下所有的device和device_driver的指针，以方便查找。
       
       bus和class指针，分别保存上层的bus或者class指针。
```

##### 2.3 功能总结

bus的注册和注销

本bus下有device或者device_driver注册到内核时的处理

本bus下有device或者device_driver从内核注销时的处理

device_drivers的probe处理

管理bus下的所有device和device_driver

### 3. 内部执行逻辑分析

##### 3.1 bus的注册

bus的注册是由bus_register接口实现的，该接口的原型是在include/linux/device.h中声明的，并在drivers/base/bus.c中实现，其原型如下：

```c
 1: /* include/linux/device.h, line 118 */
 2: extern int __must_check bus_register(struct bus_type *bus);

该功能的执行逻辑如下：

为bus_type中struct subsys_private类型的指针分配空间，并更新priv->bus和bus->p两个指针为正确的值
初始化priv->subsys.kobj的name、kset、ktype等字段，启动name就是该bus的name（它会体现在sysfs中），kset和ktype由bus模块实现，分别为bus_kset和bus_ktype
调用kset_register将priv->subsys注册到内核中，该接口同时会向sysfs中添加对应的目录（如/sys/bus/spi）
调用bus_create_file向bus目录下添加一个uevent attribute（如/sys/bus/spi/uevent）
调用kset_create_and_add分别向内核添加devices和device_drivers kset，同时会体现在sysfs中
初始化priv指针中的mutex、klist_devices和klist_drivers等变量
调用add_probe_files接口，在bus下添加drivers_probe和drivers_autoprobe两个attribute（如/sys/bus/spi/drivers_probe和/sys/bus/spi/drivers_autoprobe），其中drivers_probe允许用户空间程序主动出发指定bus下的device_driver的probe动作，而drivers_autoprobe控制是否在device或device_driver添加到内核时，自动执行probe
调用bus_add_attrs，添加由bus_attrs指针定义的bus的默认attribute，这些attributes最终会体现在/sys/bus/xxx目录下
```

##### 3.2 device和device_driver的添加

我们有在"[Linux设备模型(5)_device和device driver](http://www.wowotech.net/linux_kenrel/device_and_driver.html)”中讲过，内核提供了device_register和driver_register两个接口，供各个driver模块使用。而这两个接口的核心逻辑，是通过bus模块的bus_add_device和bus_add_driver实现的，下面我们看看这两个接口的处理逻辑。

```c
 1: /* drivers/base/base.h, line 106 */
 2: extern int bus_add_device(struct device *dev);
 3:  
 4: /* drivers/base/base.h, line 110 */ 
 5: extern int bus_add_driver(struct device_driver *drv);

bus_add_device的处理逻辑：
    调用内部的device_add_attrs接口，将由bus->dev_attrs指针定义的默认attribute添加到内核中，它们会体现在/sys/devices/xxx/xxx_device/目录中
调用sysfs_create_link接口，将该device在sysfs中的目录，链接到该bus的devices目录下，例如：
xxx# ls /sys/bus/spi/devices/spi1.0 -l                                                        
lrwxrwxrwx root     root              2014-04-11 10:46 spi1.0 -> ../../../devices/platform/s3c64xx-spi.1/spi_master/spi1/spi1.0
其中/sys/devices/…/spi1.0，为该device在sysfs中真正的位置，而为了方便管理，内核在该设备所在的bus的xxx_bus/devices目录中，创建了一个符号链接
```

